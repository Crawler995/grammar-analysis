{"version":3,"sources":["components/Header.tsx","components/GrammarInput.tsx","grammar-analysis/types/grammar.ts","components/FirstAndFollowSetShow.tsx","components/LL1AnalysisTableCompute.tsx","utils/deepEqual.ts","grammar-analysis/utils/sort/getSortedNFAStatuses.ts","components/LR0AnalysisTableCompute.tsx","components/SLR1AnalysisTableCompute.tsx","components/AnalysisSteps.tsx","grammar-analysis/utils/is/getIsGSymbolSetEqual.ts","grammar-analysis/types/grammarNChomskyType.ts","grammar-analysis/utils/getCandidates.ts","grammar-analysis/utils/is/getIsArgumentInGrammar.ts","grammar-analysis/utils/getCrossSet.ts","grammar-analysis/utils/is/getIsCanInferEmpty.ts","grammar-analysis/getFirstSet.ts","grammar-analysis/getFollowSet.ts","utils/compute/getFirstSetAndFollowSet.ts","grammar-analysis/utils/getGrammarNChomskyType.ts","grammar-analysis/getLL1AnalysisTable.ts","grammar-analysis/types/analysisTable.ts","grammar-analysis/utils/fa/getNFAFromGrammar.ts","utils/deepCopy.ts","grammar-analysis/utils/closure/getEmptyArcClosure.ts","grammar-analysis/utils/closure/getAlphaArcClosure.ts","grammar-analysis/utils/fa/getDFAFromNFA.ts","grammar-analysis/getLR0AnalysisTable.ts","grammar-analysis/getSLR1AnalysisTable.ts","components/Summary.tsx","components/Footer.tsx","pages/Index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Paragraph","Typography","Header","title","column","Item","label","role","aria-label","target","rel","href","GrammarInput","state","grammar","nonTerminals","terminals","productions","startSymbol","confirmed","mergePrime","arr","reduce","res","cur","length","push","finishHandler","values","disposedProductions","map","production","left","split","right","item","forEach","p","filter","c","test","r","Set","props","onConfirm","setState","startComputeHandler","onStartCompute","inputHandler","onInput","console","log","gutter","span","name","onFinish","this","autoComplete","List","fields","add","remove","field","key","style","display","align","fieldKey","rules","required","message","placeholder","onChange","fontSize","MinusCircleOutlined","marginTop","onClick","type","block","PlusOutlined","htmlType","disabled","marginBottom","join","React","PureComponent","FirstAndFollowSetCompute","columns","dataIndex","dataSource","data","pagination","LL1AnalysisTableCompute","table","undefined","firstRow","className","i","restRows","relationships","row","index","rows","ci","cellPadding","generateLL1AnalysisTable","deepEqual","obj1","obj","String","toString","Number","valueOf","sort","o","result","Object","keys","Array","isArray","JSON","stringify","constructor","compareNFAStatus","s1","s2","NFAToString","s","pointPos","ss1","ss2","getSortedNFAStatuses","slice","LR0AnalysisTableCompute","graphRef","useRef","useEffect","nodes","states","id","depDFA","statuses","splice","shape","edges","transformFunctions","fn","from","input","to","findIndex","arrows","setTimeout","vis","current","height","Math","max","colSpan","actionColumns","gotoColumns","secondRow","actionTable","gotoTable","generateLR0AnalysisTable","ref","SLR1AnalysisTableCompute","generateSLR1AnalysisTable","AnalysisSteps","offsetTop","direction","size","Step","status","statues","GrammarNChomskyType","getIsGSymbolSetEqual","a","b","sorted","getCandidates","getIsArgumentInGrammar","argument","includes","getCrossSet","set1","set2","item1","item2","getIsCanInferEmpty","args","cache","candidates","candidate","getFirstSet","Error","symbol","find","pop","isAllPreInferredGSymbolsContainsEmpty","isAllFirstSetContainsEmpty","curFirstSet","curFirstSetWithoutEmpty","getFollowSet","poses","temp","preLen","pos","indexOf","followSetOfLeft","firstSetOfRightRest","getFirstSetAndFollowSet","nonTerminal","firstSet","followSet","symbols","v","concat","getIsThreeGrammar","linearType","rightPart","getCandidateLinearType","getIsTwoGrammar","getGrammarNChomskyType","THREE","TWO","OTHER","getIsHasCrossSet","sets","j","getLL1AnalysisTable","fill","firstSets","tableRowIndex","isHasEmpty","tableColIndex","S","n","R","getNFAFromGrammar","resNFA","inputs","startStatus","acceptedStatuses","emptyStatus","symbolAfterPos","deepCopy","getEmptyArcClosure","inputNFA","lastLength","getAlphaArcClosure","alpha","emptyArcClosure","alphaArcClosure","getDFAFromNFA","determiningTable","rowIndex","resDFA","ri","getLR0AnalysisTable","depNFA","resTable","_","t","transformFunction","fromIndex","toIndex","inputPos","acceptedStatus","statusIndex","reduceProject","visitedNum","k","getSLR1AnalysisTable","indexes","Summary","grammarTypes","AntdFooter","Layout","Footer","textAlign","Index","stepsStatus","computeRes","firstAndFollowSet","ll1AnalysisTable","lr0AnalysisTable","slr1AnalysisTable","info","getGrammarTypes","grammarTables","confirmHandler","success","padding","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.76bdc08f.chunk.js","sourcesContent":["import React from 'react';\nimport { PageHeader, Descriptions, Typography } from 'antd';\n\nconst { Paragraph } = Typography;\n\nexport default function Header() {\n  return (\n    <PageHeader title=\"Grammar Analysis\">\n      <Descriptions column={3}>\n        <Descriptions.Item label=\"Student\">Qinglong Zhang</Descriptions.Item>\n        <Descriptions.Item label=\"ID\">1120172135</Descriptions.Item>\n        <Descriptions.Item label=\"Class\">08111702</Descriptions.Item>\n      </Descriptions>\n\n      <Paragraph>\n        This is the final assignment of class <b>Compilation Principle</b> taught by Peng Li, BIT.\n      </Paragraph>\n      <Paragraph>\n        This can compute <b>FIRST(), FOLLOW(), LL(1) / LR(0) / SLR(1) Analysis Table</b> according\n        to the given grammar.\n      </Paragraph>\n      <Paragraph>\n        <span role=\"img\" aria-label=\"\">ðŸ˜‰</span> Visit my{' '}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://github.com/Crawler995/grammar-analysis\"\n        >\n          Github\n        </a>{' '}\n        to get more information about this project, such as design / usage documentation.\n      </Paragraph>\n    </PageHeader>\n  );\n}\n","import React from 'react';\nimport { Card, Button, Form, Input, Space, Row, Col, Typography } from 'antd';\nimport { MinusCircleOutlined, PlusOutlined } from '@ant-design/icons';\nimport { EMPTY, PRIME, Grammar } from '../grammar-analysis/types/grammar';\n\ninterface IProps {\n  onInput: () => void;\n  onConfirm: () => void;\n  onStartCompute: (grammar: Grammar) => void;\n}\n\ninterface IState {\n  grammar: Grammar;\n  confirmed: boolean;\n}\n\ninterface RawProduction {\n  left: string;\n  right: string;\n}\n\nexport default class GrammarInput extends React.PureComponent<IProps, IState> {\n  state: IState = {\n    grammar: {\n      nonTerminals: [],\n      terminals: [],\n      productions: [],\n      startSymbol: ''\n    },\n    confirmed: false\n  };\n\n  mergePrime = (arr: string[]) => {\n    return arr.reduce((res, cur) => {\n      if (cur === PRIME) {\n        res[res.length - 1] += PRIME;\n      } else {\n        res.push(cur);\n      }\n      return res;\n    }, [] as string[]);\n  };\n\n  finishHandler = (values: any) => {\n    const rawProductions: RawProduction[] = values.productions;\n    const disposedProductions = rawProductions.map(production => ({\n      left: this.mergePrime(production.left.split('')),\n      right: production.right\n        .split('|')\n        .map(item => (item === 'EMPTY' ? [EMPTY] : this.mergePrime(item.split(''))))\n    }));\n\n    const nonTerminals: string[] = [];\n    const terminals: string[] = [];\n    disposedProductions.forEach(p => {\n      const { left, right } = p;\n      nonTerminals.push(...left.filter(c => /^[A-Z]'?$/.test(c)));\n      right.forEach(r => nonTerminals.push(...r.filter(c => /^[A-Z]'?$/.test(c))));\n      terminals.push(...left.filter(c => /^[^A-Z']$/.test(c)).filter(c => c !== EMPTY));\n      right.forEach(r =>\n        terminals.push(...r.filter(c => /^[^A-Z']$/.test(c)).filter(c => c !== EMPTY))\n      );\n    });\n\n    const grammar: Grammar = {\n      nonTerminals: [...new Set(nonTerminals)],\n      terminals: [...new Set(terminals)],\n      productions: disposedProductions,\n      startSymbol: nonTerminals[0]\n    };\n\n    this.props.onConfirm();\n\n    this.setState({ grammar, confirmed: true });\n  };\n\n  startComputeHandler = () => {\n    this.props.onStartCompute(this.state.grammar);\n  };\n\n  inputHandler = () => {\n    this.props.onInput()\n    this.setState({ confirmed: false });\n  }\n\n  render() {\n    console.log('render');\n    return (\n      <Card title=\"Input Grammar:\">\n        <Row gutter={24}>\n          <Col span={12}>\n            <Form name=\"grammar\" onFinish={this.finishHandler} autoComplete=\"off\">\n              <Form.List name=\"productions\">\n                {(fields, { add, remove }) => {\n                  return (\n                    <div>\n                      {fields.map(field => (\n                        <Space key={field.key} style={{ display: 'flex' }} align=\"start\">\n                          <Form.Item\n                            {...field}\n                            name={[field.name, 'left']}\n                            fieldKey={[field.fieldKey, 'left']}\n                            rules={[\n                              { required: true, message: 'Missing left part of production!' }\n                            ]}\n                          >\n                            <Input placeholder=\"left\" onChange={this.inputHandler} />\n                          </Form.Item>\n                          <span style={{ fontSize: '18px' }}>{'->'}</span>\n                          <Form.Item\n                            {...field}\n                            name={[field.name, 'right']}\n                            fieldKey={[field.fieldKey, 'right']}\n                            rules={[\n                              { required: true, message: 'Missing right part of production!' }\n                            ]}\n                          >\n                            <Input placeholder=\"right\" onChange={this.inputHandler} />\n                          </Form.Item>\n                          <MinusCircleOutlined\n                            style={{\n                              marginTop: '4px',\n                              fontSize: '24px'\n                            }}\n                            onClick={() => {\n                              remove(field.name);\n                            }}\n                          />\n                        </Space>\n                      ))}\n\n                      <Form.Item>\n                        <Button\n                          type=\"dashed\"\n                          onClick={() => {\n                            add();\n                          }}\n                          block\n                        >\n                          <PlusOutlined /> Add new production\n                        </Button>\n                      </Form.Item>\n                    </div>\n                  );\n                }}\n              </Form.List>\n\n              <Form.Item>\n                <Button type=\"primary\" htmlType=\"submit\">\n                  Confirm && Preview Grammar\n                </Button>\n              </Form.Item>\n\n              <Form.Item>\n                <Button type=\"primary\" htmlType=\"button\" onClick={this.startComputeHandler} disabled={!this.state.confirmed}>\n                  Start to Compute!\n                </Button>\n              </Form.Item>\n            </Form>\n          </Col>\n\n          <Col span={12}>\n            <Card\n              type=\"inner\"\n              title=\"Current Grammar Preview\"\n              style={{\n                marginBottom: '10px'\n              }}\n            >\n              G = ( VN, VT, S, P )<br></br>\n              VN = {`{ ${this.state.grammar.nonTerminals.join(', ')} }`}\n              <br></br>\n              VT = {`{ ${this.state.grammar.terminals.join(', ')} }`}\n              <br></br>S = {this.state.grammar.startSymbol}\n              <br></br>P ={' '}\n              {`{ ${this.state.grammar.productions\n                .map(p => {\n                  return `${p.left.join('')} -> ${p.right.map(r => r.join('')).join('|')}`;\n                })\n                .join(', ')} }`}\n            </Card>\n\n            <Typography>\n              <Typography.Paragraph>\n                Noticed: <br></br>\n                1. The /^[A-Z]'?$/ will be regarded as non-terminal and the /^[^A-Z']$/ will be\n                regarded as terminal;<br></br>\n                2. The first appeared non-terminal will be regarded as the start symbol;<br></br>\n                3. <b>You should \"Confirm && Preview Grammar\" before \"Start to Compute\"!</b>\n              </Typography.Paragraph>\n              <Typography.Paragraph>\n                e.g.<br></br>\n                {`A' -> B'a|c|${EMPTY}, B' -> d`}\n                <br></br>\n                For the first production you can input \"A'\" in left and input \"B'a|c|EMPTY\" in\n                right. <br></br>\n                The non-terminals will be [A', B'], the terminals will be [a, b, c, d], the start\n                symbol will be A'.\n              </Typography.Paragraph>\n            </Typography>\n          </Col>\n        </Row>\n      </Card>\n    );\n  }\n}\n","/**\n * @author Qinglong Zhang BIT 1120172135\n * @description The type definition of Grammar.\n */\n\n/**\n * A complete grammar G contains four components:\n * 1. A set of non-terminals: VN\n * 2. A set of terminal symbols: VT\n * 3. A start symbol: S\n * 4. A set of productions: P\n */\n\n/**\n * The length of a NonTerminal or Terminal is OFTEN 1 (a single character).\n * Specially, the length of \"A'\" is 2.\n * So use string to define it.\n */\nexport type NonTerminal = string;\nexport type Terminal = string;\n\n/**\n * EMPTY means 'Îµ'.\n */\nexport const EMPTY = 'Îµ';\n\n/**\n * be used in the new symbol in the handler of left recursion.\n * e.g.\n *\n * I->I0|Ia|Ib|a|b\n * remove the left recursion:\n * I->aI'|bI', I'->0I'|aI'|bI'|EMPTY\n */\nexport const PRIME = \"'\";\n\nexport const END = '#';\n\n/**\n * Symbol is a type in JavaScript(ES6), so use GSymbol which means VTâˆªVN.\n */\nexport type GSymbol = NonTerminal | Terminal;\n\n/**\n * e.g.\n * A production is 'AB -> ab|BC|Îµ'.\n *\n * left: ['A', 'B']\n * right: [['a', 'b'], ['B', 'C'], [EMPTY]]\n */\nexport interface Production {\n  left: GSymbol[];\n  right: GSymbol[][];\n}\n\n/**\n * We expected a Grammar like this:\n * \n  const grammar: Grammar = {\n    nonTerminals: ['S', 'A', 'B'],\n    terminals: ['a', 'b', 'c', 'd', 'p', 'q'],\n    productions: [{\n      left: ['S'],\n      right: [['A', 'p'], ['B', 'q']]\n    }, {\n      left: ['A'],\n      right: [['a'], ['c', 'A']]\n    }, {\n      left: ['B'],\n      right: [['b'], ['d', 'B']]\n    }],\n    startSymbol: 'S'\n  };\n\n  which means a grammar like this:\n  S->Ap|Bq\n  A->a|cA\n  B->b|dB\n */\nexport interface Grammar {\n  nonTerminals: NonTerminal[];\n  terminals: Terminal[];\n  productions: Production[];\n  startSymbol: NonTerminal;\n}\n","import React from 'react';\nimport { Card, Table } from 'antd';\nimport { IFirstAndFollowSet } from '../utils/compute/getFirstSetAndFollowSet';\n\ninterface IProps {\n  data: IFirstAndFollowSet[];\n}\n\nexport default function FirstAndFollowSetCompute(props: IProps) {\n  return (\n    <Card\n      title=\"FIRST() && FOLLOW()\"\n      style={{\n        marginTop: '20px'\n      }}\n    >\n      <Table\n        columns={[\n          {\n            title: 'X',\n            dataIndex: 'symbols',\n            key: 'symbols'\n          },\n          {\n            title: 'FIRST(X)',\n            dataIndex: 'firstSet',\n            key: 'firstSet'\n          },\n          {\n            title: 'FOLLOW(X)',\n            dataIndex: 'followSet',\n            key: 'followSet'\n          }\n        ]}\n        dataSource={props.data}\n        pagination={false}\n      />\n    </Card>\n  );\n}\n","import React from 'react';\nimport { Card, Typography } from 'antd';\nimport { LL1AnalysisTable } from '../grammar-analysis/types/analysisTable';\n\ninterface IProps {\n  table: LL1AnalysisTable | null | undefined;\n}\n\nexport default function LL1AnalysisTableCompute(props: IProps) {\n  const generateLL1AnalysisTable = () => {\n    const { table } = props;\n\n    if (table === undefined) {\n      return <Typography.Paragraph>Wait...</Typography.Paragraph>;\n    }\n\n    if (table === null) {\n      return <Typography.Paragraph>This grammar is not a LL(1) grammar!</Typography.Paragraph>;\n    }\n\n    const firstRow = (\n      <tr>\n        <td className=\"custom-table-header\"></td>\n        {table.columns.map((column, i) => (\n          <td className=\"custom-table-header\" key={i}>\n            <b>{column}</b>\n          </td>\n        ))}\n      </tr>\n    );\n\n    const restRows = table.relationships.map((row, index) => {\n      return (\n        <tr key={index}>\n          <td className=\"custom-table-header\">\n            <b>{table.rows[index]}</b>\n          </td>\n          {row.map((c, ci) => (\n            <td key={ci}>\n              {c === null ? '' : `${c.left} -> ${c.right.map(c => c.join('')).join('|')}`}\n            </td>\n          ))}\n        </tr>\n      );\n    });\n\n    return (\n      <table className=\"custom-table\" cellPadding={20}>\n        <tbody>\n          {firstRow}\n          {restRows}\n        </tbody>\n      </table>\n    );\n  };\n\n  return (\n    <Card\n      title=\"LL(1) Analysis Table\"\n      style={{\n        marginTop: '20px'\n      }}\n    >\n      {generateLL1AnalysisTable()}\n    </Card>\n  );\n}\n","/**\n * This is a common tool in JavaScript/TypeScript,\n * So there's no need to make by myself ^^\n *\n * copy from https://www.haorooms.com/post/js_deepcompare\n */\nconst deepEqual = (obj1: any, obj: any) => {\n  var p;\n  if (obj1 === obj) {\n    return true;\n  }\n  // some checks for native types first\n  // function and sring\n  if (typeof obj1 === 'function' || typeof obj1 === 'string' || obj1 instanceof String) {\n    return obj1.toString() === obj.toString();\n  }\n  // number\n  if (obj1 instanceof Number || typeof obj1 === 'number') {\n    if (obj instanceof Number || typeof obj === 'number') {\n      return obj1.valueOf() === obj.valueOf();\n    }\n    return false;\n  }\n  // equalsObject(null,null) and equalsObject(undefined,undefined) do not inherit from the\n  // Object.prototype so we can return false when they are passed as obj\n  if (typeof obj1 !== typeof obj || obj === null || typeof obj === 'undefined') {\n    return false;\n  }\n  function sort(o: any) {\n    var result: any = {};\n\n    if (typeof o !== 'object') {\n      return o;\n    }\n\n    Object.keys(o)\n      .sort()\n      .forEach(function (key) {\n        result[key] = sort(o[key]);\n      });\n\n    return result;\n  }\n  if (typeof obj1 === 'object') {\n    if (Array.isArray(obj1)) {\n      // check on arrays\n      return JSON.stringify(obj1) === JSON.stringify(obj);\n    } else {\n      // anyway objects\n      for (p in obj1) {\n        if (typeof obj1[p] !== typeof obj[p]) {\n          return false;\n        }\n        if ((obj1[p] === null) !== (obj[p] === null)) {\n          return false;\n        }\n        switch (typeof obj1[p]) {\n          case 'undefined':\n            if (typeof obj[p] !== 'undefined') {\n              return false;\n            }\n            break;\n          case 'object':\n            if (\n              obj1[p] !== null &&\n              obj[p] !== null &&\n              (obj1[p].constructor.toString() !== obj[p].constructor.toString() ||\n                !deepEqual(obj1[p], obj[p]))\n            ) {\n              return false;\n            }\n            break;\n          case 'function':\n            if (obj1[p].toString() !== obj[p].toString()) {\n              return false;\n            }\n            break;\n          default:\n            if (obj1[p] !== obj[p]) {\n              return false;\n            }\n        }\n      }\n    }\n  }\n  // at least check them with JSON\n  return JSON.stringify(sort(obj1)) === JSON.stringify(sort(obj));\n};\n\nexport default deepEqual;\n","import { NFAStatus } from '../../types/fa';\n\nconst getSortedNFAStatuses = (s: NFAStatus[]) => {\n  return s.slice(0).sort((s1, s2) => compareNFAStatus(s1, s2));\n};\n\nexport const compareNFAStatus = (s1: NFAStatus, s2: NFAStatus) => {\n  const NFAToString = (s: NFAStatus) => s.left + s.pointPos + s.right.join('');\n  const ss1 = NFAToString(s1);\n  const ss2 = NFAToString(s2);\n  return ss1 < ss2 ? -1 : ss1 === ss2 ? 0 : 1;\n};\n\nexport default getSortedNFAStatuses;\n","import React, { useEffect, useRef } from 'react';\nimport { Card, Typography, Col, Row } from 'antd';\nimport deepEqual from '../utils/deepEqual';\nimport * as vis from 'vis-network';\nimport getSortedNFAStatuses from '../grammar-analysis/utils/sort/getSortedNFAStatuses';\nimport { LR0AnalysisTable } from '../grammar-analysis/types/analysisTable';\n\ninterface IProps {\n  table: LR0AnalysisTable | null | undefined;\n}\n\nexport default function LR0AnalysisTableCompute(props: IProps) {\n  const graphRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const { table } = props;\n\n    if (table === undefined) {\n      return;\n    }\n\n    if (table === null) {\n      return;\n    }\n\n    const nodes: vis.Node[] = table.states.map((state, index) => {\n      return {\n        id: state,\n        label:\n          '' +\n          index +\n          '\\n' +\n          table.depDFA.statuses[index]\n            .map(s => {\n              const right = s.right.slice(0);\n              right.splice(s.pointPos, 0, 'Â·');\n\n              return `${s.left} -> ${right.join('')}`;\n            })\n            .join('\\n'),\n        shape: 'box'\n      };\n    });\n\n    const edges: vis.Edge[] = table.depDFA.transformFunctions.map((fn, index) => {\n      const { from, input, to } = fn;\n\n      const fromId = table.depDFA.statuses.findIndex(s =>\n        deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(from))\n      );\n      const toId = table.depDFA.statuses.findIndex(s =>\n        deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(to))\n      );\n\n      return {\n        from: fromId,\n        to: toId,\n        label: input,\n        arrows: {\n          to: true\n        }\n      };\n    });\n\n    setTimeout(() => {\n      new vis.Network(\n        graphRef.current!,\n        { nodes, edges },\n        {\n          height: `${Math.max(table.depDFA.statuses.length * 62, 400)}px`\n        }\n      );\n    }, 100);\n  }, [props, props.table]);\n\n  const generateLR0AnalysisTable = () => {\n    const { table } = props;\n\n    if (table === undefined) {\n      return <Typography.Paragraph>Wait...</Typography.Paragraph>;\n    }\n\n    if (table === null) {\n      return <Typography.Paragraph>This grammar is not a LR(0) grammar!</Typography.Paragraph>;\n    }\n\n    const firstRow = (\n      <tr>\n        <td className=\"custom-table-header\"></td>\n        <td className=\"custom-table-header\" colSpan={table.actionColumns.length}>\n          <b>ACTION</b>\n        </td>\n        <td className=\"custom-table-header\" colSpan={table.gotoColumns.length}>\n          <b>GOTO</b>\n        </td>\n      </tr>\n    );\n\n    const secondRow = (\n      <tr>\n        <td className=\"custom-table-header\"></td>\n        {table.actionColumns.map((c, i) => (\n          <td key={i} className=\"custom-table-header\">\n            <b>{c}</b>\n          </td>\n        ))}\n        {table.gotoColumns.map((c, i) => (\n          <td key={i} className=\"custom-table-header\">\n            <b>{c}</b>\n          </td>\n        ))}\n      </tr>\n    );\n\n    const restRows = (\n      <>\n        {table.states.map((state, index) => (\n          <tr key={index}>\n            <td className=\"custom-table-header\">\n              <b>{state}</b>\n            </td>\n            {table.actionTable[index].map((c, i) => (\n              <td key={i}>{c ?? ''}</td>\n            ))}\n            {table.gotoTable[index].map((c, i) => (\n              <td key={i}>{c ?? ''}</td>\n            ))}\n          </tr>\n        ))}\n      </>\n    );\n\n    return (\n      <table className=\"custom-table\" cellPadding={20}>\n        <tbody>\n          {firstRow}\n          {secondRow}\n          {restRows}\n        </tbody>\n      </table>\n    );\n  };\n\n  return (\n    <Card\n      title=\"LR(0) Analysis Table\"\n      style={{\n        marginTop: '20px'\n      }}\n    >\n      <Row gutter={24}>\n        <Col span={9}>{generateLR0AnalysisTable()}</Col>\n        <Col span={15}>\n          <Card type=\"inner\" title=\"DFA Graph\">\n            <div ref={graphRef}></div>\n          </Card>\n        </Col>\n      </Row>\n    </Card>\n  );\n}\n","import React, { useEffect, useRef } from 'react';\nimport { Card, Typography, Col, Row } from 'antd';\nimport deepEqual from '../utils/deepEqual';\nimport * as vis from 'vis-network';\nimport getSortedNFAStatuses from '../grammar-analysis/utils/sort/getSortedNFAStatuses';\nimport { SLR1AnalysisTable } from '../grammar-analysis/types/analysisTable';\n\ninterface IProps {\n  table: SLR1AnalysisTable | null | undefined;\n}\n\nexport default function SLR1AnalysisTableCompute(props: IProps) {\n  const graphRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const { table } = props;\n\n    if (table === undefined) {\n      return;\n    }\n\n    if (table === null) {\n      return;\n    }\n\n    const nodes: vis.Node[] = table.states.map((state, index) => {\n      return {\n        id: state,\n        label:\n          '' +\n          index +\n          '\\n' +\n          table.depDFA.statuses[index]\n            .map(s => {\n              const right = s.right.slice(0);\n              right.splice(s.pointPos, 0, 'Â·');\n\n              return `${s.left} -> ${right.join('')}`;\n            })\n            .join('\\n'),\n        shape: 'box'\n      };\n    });\n\n    const edges: vis.Edge[] = table.depDFA.transformFunctions.map((fn, index) => {\n      const { from, input, to } = fn;\n\n      const fromId = table.depDFA.statuses.findIndex(s =>\n        deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(from))\n      );\n      const toId = table.depDFA.statuses.findIndex(s =>\n        deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(to))\n      );\n\n      return {\n        from: fromId,\n        to: toId,\n        label: input,\n        arrows: {\n          to: true\n        }\n      };\n    });\n\n    setTimeout(() => {\n      new vis.Network(\n        graphRef.current!,\n        { nodes, edges },\n        {\n          height: `${Math.max(table.depDFA.statuses.length * 62, 400)}px`\n        }\n      );\n    }, 100);\n  }, [props, props.table]);\n\n  const generateSLR1AnalysisTable = () => {\n    const { table } = props;\n\n    if (table === undefined) {\n      return <Typography.Paragraph>Wait...</Typography.Paragraph>;\n    }\n\n    if (table === null) {\n      return <Typography.Paragraph>This grammar is not a SLR(1) grammar!</Typography.Paragraph>;\n    }\n\n    const firstRow = (\n      <tr>\n        <td className=\"custom-table-header\"></td>\n        <td className=\"custom-table-header\" colSpan={table.actionColumns.length}>\n          <b>ACTION</b>\n        </td>\n        <td className=\"custom-table-header\" colSpan={table.gotoColumns.length}>\n          <b>GOTO</b>\n        </td>\n      </tr>\n    );\n\n    const secondRow = (\n      <tr>\n        <td className=\"custom-table-header\"></td>\n        {table.actionColumns.map((c, i) => (\n          <td key={i} className=\"custom-table-header\">\n            <b>{c}</b>\n          </td>\n        ))}\n        {table.gotoColumns.map((c, i) => (\n          <td key={i} className=\"custom-table-header\">\n            <b>{c}</b>\n          </td>\n        ))}\n      </tr>\n    );\n\n    const restRows = (\n      <>\n        {table.states.map((state, index) => (\n          <tr key={index}>\n            <td className=\"custom-table-header\">\n              <b>{state}</b>\n            </td>\n            {table.actionTable[index].map((c, i) => (\n              <td key={i}>{c ?? ''}</td>\n            ))}\n            {table.gotoTable[index].map((c, i) => (\n              <td key={i}>{c ?? ''}</td>\n            ))}\n          </tr>\n        ))}\n      </>\n    );\n\n    return (\n      <table className=\"custom-table\" cellPadding={20}>\n        <tbody>\n          {firstRow}\n          {secondRow}\n          {restRows}\n        </tbody>\n      </table>\n    );\n  };\n\n  return (\n    <Card\n      title=\"SLR(1) Analysis Table\"\n      style={{\n        marginTop: '20px'\n      }}\n    >\n      <Row gutter={24}>\n        <Col span={9}>{generateSLR1AnalysisTable()}</Col>\n        <Col span={15}>\n          <Card type=\"inner\" title=\"DFA Graph\">\n            <div ref={graphRef}></div>\n          </Card>\n        </Col>\n      </Row>\n    </Card>\n  );\n}\n","import React from 'react';\nimport { Affix, Steps } from 'antd';\n\ninterface IProps {\n  statues: boolean[];\n}\n\nexport default function AnalysisSteps(props: IProps) {\n  const titles = ['Input Grammar', 'FIRST() & FOLLOW()', 'LL(1)', 'LR(0)', 'SLR(1)', 'Summary'];\n\n  return (\n    <Affix offsetTop={250}>\n      <Steps direction=\"vertical\" size=\"small\">\n        {titles.map((title, i) => (\n          <Steps.Step\n            key={title}\n            title={title}\n            status={\n              props.statues[i] === undefined ? undefined : props.statues[i] ? 'finish' : 'error'\n            }\n          />\n        ))}\n      </Steps>\n    </Affix>\n  );\n}\n","import { GSymbol } from '../../types/grammar';\n\n/**\n * Get whether two symbols are deeply equal.\n * e.g.\n *\n * a: ['a', 'b']\n * b: ['a', 'b']\n * output: true\n *\n * a: ['a', 'c']\n * b: ['a', 'b']\n * output: false\n */\nconst getIsGSymbolSetEqual = (a: GSymbol[], b: GSymbol[], sorted: boolean = true) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  if (sorted) {\n    a = a.slice(0).sort();\n    b = b.slice(0).sort();\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport default getIsGSymbolSetEqual;\n","enum GrammarNChomskyType {\n  OTHER,\n  TWO,\n  THREE\n}\n\nexport default GrammarNChomskyType;\n","import { Grammar, GSymbol } from '../types/grammar';\nimport getIsGSymbolSetEqual from './is/getIsGSymbolSetEqual';\n\n/**\n * Get the inferred symbols (the right) by the given left symbol.\n * e.g.\n * A -> ab | c\n *\n * left: A\n * output: [['a', 'b'], ['c']]\n */\nconst getCandidates = (grammar: Grammar, left: GSymbol[]) => {\n  const { productions } = grammar;\n  const res = [];\n\n  for (let i = 0; i < productions.length; i++) {\n    const production = productions[i];\n\n    if (getIsGSymbolSetEqual(production.left, left)) {\n      res.push(...production.right);\n    }\n  }\n\n  return res;\n};\n\nexport default getCandidates;\n","import { Grammar, GSymbol, EMPTY } from '../../types/grammar';\n\n/**\n * Get whether the given symbols are in non-terminals or terminals in the given grammar.\n * e.g.\n * A -> ab\n * B -> ac\n *\n * argument: ['a', 'A']\n * output: true\n *\n * argument: ['e', 'f']\n * output: false\n */\nconst getIsArgumentInGrammar = (grammar: Grammar, argument: GSymbol[]) => {\n  if (argument.length === 1 && argument[0] === EMPTY) {\n    return true;\n  }\n\n  const { nonTerminals, terminals } = grammar;\n\n  return argument.reduce(\n    (res, cur) => res && (nonTerminals.includes(cur) || terminals.includes(cur)),\n    true\n  );\n};\n\nexport default getIsArgumentInGrammar;\n","import { GSymbol } from '../types/grammar';\n\nconst getCrossSet = (set1: GSymbol[], set2: GSymbol[]) => {\n  const res: GSymbol[] = [];\n\n  set1.forEach(item1 => {\n    set2.forEach(item2 => {\n      if (item1 === item2) {\n        res.push(item1);\n      }\n    });\n  });\n\n  return res;\n};\n\nexport default getCrossSet;\n","import { Grammar, GSymbol, NonTerminal, EMPTY } from '../../types/grammar';\nimport getCandidates from '../getCandidates';\nimport getCrossSet from '../getCrossSet';\n\n/**\n * Assert that the given grammar is a two grammar.\n */\nconst getIsCanInferEmpty = (\n  grammar: Grammar,\n  args: GSymbol,\n  cache: NonTerminal[] = []\n): boolean => {\n  if (cache.includes(args)) {\n    return false;\n  }\n\n  if (args === EMPTY) {\n    return true;\n  } else if (grammar.nonTerminals.includes(args)) {\n    const candidates = getCandidates(grammar, [args]);\n\n    for (let i = 0; i < candidates.length; i++) {\n      const candidate = candidates[i];\n\n      if (candidate.length === 1 && candidate[0] === EMPTY) {\n        return true;\n      }\n\n      if (getCrossSet(candidate, grammar.terminals).length === 0) {\n        const res = candidate.reduce(\n          (res, cur) => res && getIsCanInferEmpty(grammar, cur, [...cache, args]),\n          true\n        );\n        if (res) return true;\n      }\n    }\n\n    return false;\n  } else if (grammar.terminals.includes(args)) {\n    return false;\n  } else {\n    return false;\n  }\n};\n\nexport default getIsCanInferEmpty;\n","import { Grammar, GSymbol, EMPTY, NonTerminal } from './types/grammar';\nimport getCandidates from './utils/getCandidates';\nimport getIsArgumentInGrammar from './utils/is/getIsArgumentInGrammar';\nimport getIsCanInferEmpty from './utils/is/getIsCanInferEmpty';\n\n/**\n * Get FIRST(*).\n * @param grammar A Grammar.\n * @param argument X or X1X2...Xk, such as ['A'] or ['A', 'b', 'C'], which means FIRST('A') or FIRST('AbC')\n */\nconst getFirstSet = (\n  grammar: Grammar,\n  argument: GSymbol[],\n  cache: NonTerminal[] = []\n): GSymbol[] => {\n  if (!getIsArgumentInGrammar(grammar, argument)) {\n    throw new Error(\n      'The argument must be included by the non-terminal set or terminal set of the given grammar.'\n    );\n  }\n\n  // the argument is ['A'] or ['a']\n  if (argument.length === 1) {\n    const symbol = argument[0];\n\n    // the symbol is a terminal or EMPTY, e.g. ['a']\n    if (grammar.terminals.includes(symbol) || symbol === EMPTY) {\n      return [symbol];\n    }\n    // the symbol is a non-terminal, e.g. ['A']\n    else {\n      // if there's a production: A -> aBc | d\n      // the candidates will be [['a', 'B', 'c'], ['d']]\n      const candidates = getCandidates(grammar, argument);\n\n      // res = FIRST('aBc')âˆªFIRST('d')\n      const res: GSymbol[] = [];\n      cache.push(symbol);\n      candidates.forEach(candidate => {\n        if (symbol !== candidate[0]) {\n          // indirect left recursion\n          if (cache.includes(candidate[0])) {\n            let candidatesContainsEmpty =\n              getCandidates(grammar, [candidate[0]]).find(\n                candidate => candidate.length === 1 && candidate[0] === EMPTY\n              ) !== undefined;\n            if (candidatesContainsEmpty) {\n              // ignore the candidate which cause indirect left recursion\n              res.push(...getFirstSet(grammar, candidate.slice(1), cache));\n            }\n          } else {\n            res.push(...getFirstSet(grammar, candidate, cache));\n          }\n        } else {\n          // direct left recursion\n          // A -> Ad|EMPTY\n          // now the candidate is ['A', 'd']\n          let candidatesContainsEmpty =\n            candidates.find(candidate => candidate.length === 1 && candidate[0] === EMPTY) !==\n            undefined;\n          if (candidatesContainsEmpty) {\n            // ignore the candidate which cause direct left recursion\n            res.push(...getFirstSet(grammar, candidate.slice(1), cache));\n          }\n        }\n      });\n      cache.pop();\n\n      return [...new Set(res)].sort();\n    }\n  }\n\n  // the argument is like ['a', 'A', 'c'], which means FIRST('aAc')\n  else {\n    let isAllPreInferredGSymbolsContainsEmpty = true;\n    let isAllFirstSetContainsEmpty = true;\n    const res: GSymbol[] = [];\n\n    for (let i = 0; i < argument.length; i++) {\n      if (isAllPreInferredGSymbolsContainsEmpty) {\n        const curFirstSet = getFirstSet(grammar, [argument[i]], cache);\n        const curFirstSetWithoutEmpty = curFirstSet.filter(symbol => symbol !== EMPTY);\n        res.push(...curFirstSetWithoutEmpty);\n\n        isAllPreInferredGSymbolsContainsEmpty = getIsCanInferEmpty(grammar, argument[i]);\n      } else {\n        isAllFirstSetContainsEmpty = false;\n        break;\n      }\n    }\n\n    if (!isAllPreInferredGSymbolsContainsEmpty) {\n      isAllFirstSetContainsEmpty = false;\n    }\n\n    if (isAllFirstSetContainsEmpty) {\n      res.push(EMPTY);\n    }\n\n    return [...new Set(res)].sort();\n  }\n};\n\nexport default getFirstSet;\n","import { GSymbol, Grammar, NonTerminal, EMPTY, END, Terminal } from './types/grammar';\nimport getIsArgumentInGrammar from './utils/is/getIsArgumentInGrammar';\nimport getFirstSet from './getFirstSet';\n\nconst getFollowSet = (\n  grammar: Grammar,\n  argument: NonTerminal,\n  cache: NonTerminal[] = []\n): Terminal[] => {\n  if (!getIsArgumentInGrammar(grammar, [argument])) {\n    throw new Error(\n      'The argument must be included by the non-terminal set or terminal set of the given grammar.'\n    );\n  }\n\n  const res: GSymbol[] = [];\n\n  // A -> a | cA\n  // endless recursion\n  if (cache.includes(argument)) {\n    return res;\n  }\n\n  if (argument === grammar.startSymbol) {\n    res.push(END);\n  }\n\n  grammar.productions.forEach((production, index) => {\n    const { left, right } = production;\n\n    right.forEach((item, index) => {\n      // may appear more than one time\n      // const pos = item.indexOf(argument);\n      const poses = [];\n      let temp = item.slice(0);\n      let preLen = 0;\n\n      while (true) {\n        const pos = temp.indexOf(argument);\n        if (pos === -1) {\n          break;\n        }\n\n        poses.push(pos + preLen);\n        temp = temp.slice(pos + 1);\n        preLen += pos + 1;\n      }\n\n      poses.forEach(pos => {\n        if (pos > -1) {\n          const followSetOfLeft = getFollowSet(grammar, left[0], [...cache, argument]);\n\n          // res includes FIRST(left)\n          if (pos === item.length - 1) {\n            res.push(...followSetOfLeft);\n          }\n\n          const firstSetOfRightRest = getFirstSet(grammar, item.slice(pos + 1));\n          res.push(...firstSetOfRightRest.filter(item => item !== EMPTY));\n\n          if (firstSetOfRightRest.includes(EMPTY)) {\n            res.push(...followSetOfLeft);\n          }\n        }\n      });\n    });\n  });\n\n  return [...new Set(res)].sort();\n};\n\nexport default getFollowSet;\n","import { Grammar } from '../../grammar-analysis/types/grammar';\nimport getFirstSet from '../../grammar-analysis/getFirstSet';\nimport getFollowSet from '../../grammar-analysis/getFollowSet';\n\nexport interface IFirstAndFollowSet {\n  key: string;\n  symbols: string;\n  firstSet: string;\n  followSet: string;\n}\n\nconst getFirstSetAndFollowSet = (grammar: Grammar) => {\n  const { nonTerminals, productions } = grammar;\n  const data: IFirstAndFollowSet[] = [];\n  data.push(\n    ...nonTerminals.map(nonTerminal => {\n      const firstSet = getFirstSet(grammar, [nonTerminal]);\n      const followSet = getFollowSet(grammar, nonTerminal);\n\n      return {\n        key: nonTerminal,\n        symbols: nonTerminal,\n        firstSet: `{ ${firstSet.join(', ')} }`,\n        followSet: `{ ${followSet.join(', ')} }`\n      };\n    })\n  );\n  productions.forEach(production => {\n    const temp: IFirstAndFollowSet[] = [];\n    production.right.forEach(c => {\n      const firstSet = getFirstSet(grammar, c);\n\n      temp.push({\n        key: c.join(''),\n        symbols: c.join(''),\n        firstSet: `{ ${firstSet.join(', ')} }`,\n        followSet: ''\n      });\n    });\n    data.push(...temp);\n  });\n\n  return data.reduce((res, cur) => {\n    if (res.findIndex(v => v.symbols === cur.symbols) === -1) {\n      return res.concat(cur);\n    }\n    return res;\n  }, [] as IFirstAndFollowSet[]);\n};\n\nexport default getFirstSetAndFollowSet;\n","import { Grammar, GSymbol, EMPTY } from '../types/grammar';\nimport GrammarNChomskyType from '../types/grammarNChomskyType';\n\nconst getGrammarNChomskyType = (grammar: Grammar): GrammarNChomskyType => {\n  if (getIsThreeGrammar(grammar)) return GrammarNChomskyType.THREE;\n  if (getIsTwoGrammar(grammar)) return GrammarNChomskyType.TWO;\n\n  return GrammarNChomskyType.OTHER;\n};\n\nexport const getIsThreeGrammar = (grammar: Grammar) => {\n  const { productions } = grammar;\n  let linearType = undefined;\n\n  for (const production of productions) {\n    const { left, right } = production;\n    // Aa -> B\n    if (left.length !== 1) {\n      return false;\n    }\n\n    // split \"A -> a|b\" to \"A -> a, A -> b\"\n    for (const rightPart of right) {\n      const type = getCandidateLinearType(grammar, rightPart);\n      if (type === 'none') {\n        return false;\n      } else if (type === 'uncertain') {\n        continue;\n      } else {\n        if (linearType === undefined) {\n          linearType = type;\n        } else {\n          if (linearType !== type) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n};\n\nexport type LinearType = 'left' | 'right' | 'none' | 'uncertain';\n\nexport const getCandidateLinearType = (grammar: Grammar, candidate: GSymbol[]): LinearType => {\n  if (candidate.length > 2) {\n    return 'none';\n  }\n\n  const { terminals, nonTerminals } = grammar;\n\n  if (candidate.length === 1) {\n    return terminals.includes(candidate[0]) || candidate[0] === EMPTY ? 'uncertain' : 'none';\n  }\n  if (candidate.length === 2) {\n    if (\n      nonTerminals.includes(candidate[0]) &&\n      (terminals.includes(candidate[1]) || candidate[1] === EMPTY)\n    ) {\n      return 'left';\n    }\n    if (\n      (terminals.includes(candidate[0]) || candidate[0] === EMPTY) &&\n      nonTerminals.includes(candidate[1])\n    ) {\n      return 'right';\n    }\n  }\n\n  return 'none';\n};\n\nexport const getIsTwoGrammar = (grammar: Grammar) => {\n  const { productions, nonTerminals } = grammar;\n\n  for (const production of productions) {\n    const { left } = production;\n\n    // Aa -> ...\n    if (left.length !== 1) {\n      return false;\n    }\n    // a -> ...\n    if (!nonTerminals.includes(left[0])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport default getGrammarNChomskyType;\n","import { Grammar, Terminal, END, EMPTY } from './types/grammar';\nimport getFirstSet from './getFirstSet';\nimport getCrossSet from './utils/getCrossSet';\nimport { LL1AnalysisTable } from './types/analysisTable';\nimport getFollowSet from './getFollowSet';\nimport getGrammarNChomskyType from './utils/getGrammarNChomskyType';\nimport GrammarNChomskyType from './types/grammarNChomskyType';\n\nconst getLL1AnalysisTable = (grammar: Grammar): LL1AnalysisTable | null => {\n  if (getGrammarNChomskyType(grammar) === GrammarNChomskyType.OTHER) {\n    return null;\n  }\n\n  const res: LL1AnalysisTable = {\n    rows: [...grammar.nonTerminals],\n    columns: [...grammar.terminals, END],\n    relationships: []\n  };\n\n  res.relationships = new Array(grammar.nonTerminals.length);\n  for (let i = 0; i < res.relationships.length; i++) {\n    res.relationships[i] = new Array(grammar.terminals.length + 1).fill(null);\n  }\n\n  for (let i = 0; i < grammar.productions.length; i++) {\n    const production = grammar.productions[i];\n\n    const { left, right } = production;\n    const firstSets: Terminal[][] = [];\n\n    const tableRowIndex = res.rows.indexOf(left[0]);\n\n    for (let j = 0; j < right.length; j++) {\n      const candidate = right[j];\n\n      const curFirstSet = getFirstSet(grammar, candidate);\n      firstSets.push(curFirstSet);\n\n      // there's cross set between first sets\n      // not LL(1) grammar\n      if (getIsHasCrossSet(firstSets)) {\n        return null;\n      }\n\n      let isHasEmpty = curFirstSet.includes(EMPTY);\n\n      for (let i = 0; i < curFirstSet.length; i++) {\n        const item = curFirstSet[i];\n\n        if (item !== EMPTY) {\n          const tableColIndex = res.columns.indexOf(item);\n\n          // multiple definition\n          // not LL(1) grammar\n          if (res.relationships[tableRowIndex][tableColIndex] !== null) {\n            return null;\n          }\n\n          res.relationships[tableRowIndex][tableColIndex] = {\n            left,\n            right: [candidate]\n          };\n        }\n      }\n\n      if (isHasEmpty) {\n        const followSet = getFollowSet(grammar, left[0]);\n\n        for (let i = 0; i < followSet.length; i++) {\n          const item = followSet[i];\n\n          const tableColIndex = res.columns.indexOf(item);\n\n          // multiple definition\n          // not LL(1) grammar\n          if (res.relationships[tableRowIndex][tableColIndex] !== null) {\n            return null;\n          }\n\n          res.relationships[tableRowIndex][tableColIndex] = {\n            left: left,\n            right: [candidate]\n          };\n        }\n      }\n    }\n  }\n\n  return res;\n};\n\nconst getIsHasCrossSet = (sets: Terminal[][]) => {\n  for (let i = 0; i < sets.length - 1; i++) {\n    const set1 = sets[i];\n    for (let j = i + 1; j < sets.length; j++) {\n      const set2 = sets[j];\n\n      if (getCrossSet(set1, set2).length !== 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexport default getLL1AnalysisTable;\n","import { NonTerminal, Terminal, END, Production } from './grammar';\nimport { DFA } from './fa';\n\n/**\n * e.g.\n * \n  const table: LL1AnalysisTable = {\n    nonTerminals: ['S', 'A'],\n    terminals: ['+', '*'],\n    relationships: [\n      [null, { left: ['S'], right: [['*']] }],\n      [{ left: ['A'], right: [['+']] }, null]\n    ]\n  };\n */\nexport interface LL1AnalysisTable {\n  rows: NonTerminal[];\n  columns: (Terminal | typeof END)[];\n  relationships: (Production | null)[][];\n}\n\nexport type State = number;\nexport const S = (n: State) => `S${n}`;\nexport const R = (n: State) => `r${n}`;\nexport const ACC = `acc`;\n\nexport interface LR0AnalysisTable {\n  states: State[];\n  actionColumns: (Terminal | typeof END)[];\n  gotoColumns: NonTerminal[];\n  actionTable: (ReturnType<typeof S> | ReturnType<typeof R> | typeof ACC | null)[][];\n  gotoTable: (State | null)[][];\n  depDFA: DFA;\n}\n\nexport type SLR1AnalysisTable = LR0AnalysisTable;\n","import { Grammar, EMPTY } from '../../types/grammar';\nimport { NFAStatus, NFA } from '../../types/fa';\nimport getCandidates from '../getCandidates';\n\nconst getNFAFromGrammar = (grammar: Grammar) => {\n  const resNFA: NFA = {\n    inputs: [...grammar.terminals, ...grammar.nonTerminals],\n    statuses: [],\n    startStatus: {\n      left: grammar.startSymbol,\n      right: getCandidates(grammar, [grammar.startSymbol])[0],\n      pointPos: 0\n    },\n    acceptedStatuses: [],\n    transformFunctions: []\n  };\n\n  grammar.productions.forEach(production => {\n    const { left, right } = production;\n\n    right.forEach(candidate => {\n      for (let i = 0; i < candidate.length; i++) {\n        // A->EMPTY => A->Â·\n        if (candidate.length === 1 && candidate[0] === EMPTY) {\n          const emptyStatus: NFAStatus = {\n            left: left[0],\n            right: [],\n            pointPos: 0\n          };\n          resNFA.statuses.push(emptyStatus);\n          resNFA.acceptedStatuses.push(emptyStatus);\n\n          break;\n        }\n\n        const from: NFAStatus = {\n          left: left[0],\n          right: candidate,\n          pointPos: i\n        };\n\n        const to: NFAStatus = {\n          left: left[0],\n          right: candidate,\n          pointPos: i + 1\n        };\n\n        resNFA.statuses.push(from);\n        if (i === candidate.length - 1) {\n          resNFA.statuses.push(to);\n          resNFA.acceptedStatuses.push(to);\n        }\n\n        // X -> AÂ·b to X -> AbÂ·\n        resNFA.transformFunctions.push({\n          from,\n          to,\n          input: candidate[i]\n        });\n      }\n    });\n  });\n\n  resNFA.transformFunctions.forEach(fn => {\n    const symbolAfterPos = fn.from.right[fn.from.pointPos];\n    // X -> Î±Â·A...\n    if (grammar.nonTerminals.includes(symbolAfterPos)) {\n      resNFA.statuses.forEach(status => {\n        // A -> Â·Î±\n        if (status.left === symbolAfterPos && status.pointPos === 0) {\n          resNFA.transformFunctions.push({\n            from: fn.from,\n            to: status,\n            input: EMPTY\n          });\n        }\n      });\n    }\n  });\n\n  return resNFA;\n};\n\nexport default getNFAFromGrammar;\n","function deepCopy<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  const isArray = Array.isArray(obj);\n  const res: any = isArray ? [] : {};\n\n  Object.keys(obj).forEach(key => (res[key] = deepCopy((obj as any)[key])));\n  return res;\n}\n\nexport default deepCopy;\n","import { NFA, NFAStatus } from '../../types/fa';\nimport deepEqual from '../../../utils/deepEqual';\nimport { EMPTY } from '../../types/grammar';\nimport deepCopy from '../../../utils/deepCopy';\n\nconst getEmptyArcClosure = (inputNFA: NFA, statuses: NFAStatus[]): NFAStatus[] => {\n  const { transformFunctions } = inputNFA;\n  const res: NFAStatus[] = [...statuses];\n\n  let lastLength = res.length;\n\n  while (true) {\n    res.forEach(s => {\n      transformFunctions.forEach(fn => {\n        if (deepEqual(fn.from, s) && fn.input === EMPTY) {\n          if (!res.reduce((res, cur) => res || deepEqual(cur, fn.to), false)) {\n            res.push(deepCopy(fn.to));\n          }\n        }\n      });\n    });\n\n    if (res.length === lastLength) break;\n    else lastLength = res.length;\n  }\n\n  return res;\n};\n\nexport default getEmptyArcClosure;\n","import { NFAStatus, NFA } from '../../types/fa';\nimport getEmptyArcClosure from './getEmptyArcClosure';\nimport deepCopy from '../../../utils/deepCopy';\nimport { GSymbol } from '../../types/grammar';\nimport deepEqual from '../../../utils/deepEqual';\n\nconst getAlphaArcClosure = (inputNFA: NFA, statuses: NFAStatus[], alpha: GSymbol): NFAStatus[] => {\n  const emptyArcClosure = getEmptyArcClosure(inputNFA, statuses);\n\n  const { transformFunctions } = inputNFA;\n  const alphaArcClosure: NFAStatus[] = [];\n\n  emptyArcClosure.forEach(s => {\n    transformFunctions.forEach(fn => {\n      if (deepEqual(fn.from, s) && fn.input === alpha) {\n        if (!alphaArcClosure.reduce((res, cur) => res || deepEqual(cur, fn.to), false)) {\n          alphaArcClosure.push(deepCopy(fn.to));\n        }\n      }\n    });\n  });\n\n  const res: NFAStatus[] = [];\n  alphaArcClosure.forEach(s => {\n    res.push(...getEmptyArcClosure(inputNFA, [s]));\n  });\n\n  return res;\n};\n\nexport default getAlphaArcClosure;\n","import { NFA, NFAStatus, DFA, DFAStatus } from '../../types/fa';\nimport getEmptyArcClosure from '../closure/getEmptyArcClosure';\nimport { GSymbol, EMPTY } from '../../types/grammar';\nimport getAlphaArcClosure from '../closure/getAlphaArcClosure';\nimport deepEqual from '../../../utils/deepEqual';\nimport getSortedNFAStatuses from '../sort/getSortedNFAStatuses';\n\ninterface DeterminingTable {\n  rows: NFAStatus[][];\n  columns: GSymbol[];\n  relationships: (NFAStatus[] | null)[][];\n}\n\nconst getDFAFromNFA = (inputNFA: NFA) => {\n  const startEmptyArcClosure = getEmptyArcClosure(inputNFA, [inputNFA.startStatus]);\n\n  const determiningTable: DeterminingTable = {\n    rows: [startEmptyArcClosure],\n    columns: [...new Set(inputNFA.transformFunctions.map(fn => fn.input).filter(c => c !== EMPTY))],\n    relationships: []\n  };\n\n  let acceptedStatuses: DFAStatus[] = [];\n  let rowIndex = 0;\n  while (true) {\n    const s = determiningTable.rows[rowIndex];\n    const row: (NFAStatus[] | null)[] = [];\n\n    // I-Î±\n    determiningTable.columns.forEach(column => {\n      const alphaArcClosure = getAlphaArcClosure(inputNFA, s, column);\n      row.push(alphaArcClosure.length === 0 ? null : alphaArcClosure);\n\n      // if not exists in row before\n      // add it into row\n      if (\n        alphaArcClosure.length !== 0 &&\n        !determiningTable.rows.reduce(\n          (res, cur) =>\n            res || deepEqual(getSortedNFAStatuses(cur), getSortedNFAStatuses(alphaArcClosure)),\n          false\n        )\n      ) {\n        determiningTable.rows.push(alphaArcClosure);\n\n        // includes accepted status in NFA\n        if (\n          inputNFA.acceptedStatuses.reduce(\n            (res, cur) => res || alphaArcClosure.find(s => deepEqual(s, cur)) !== undefined,\n            false\n          )\n        ) {\n          acceptedStatuses.push(alphaArcClosure);\n        }\n      }\n    });\n\n    determiningTable.relationships.push(row);\n\n    rowIndex++;\n    if (rowIndex === determiningTable.rows.length) {\n      break;\n    }\n  }\n\n  const resDFA: DFA = {\n    inputs: inputNFA.inputs,\n    statuses: determiningTable.rows,\n    startStatus: determiningTable.rows[0],\n    acceptedStatuses,\n    transformFunctions: []\n  };\n\n  const { relationships } = determiningTable;\n  determiningTable.rows.forEach((row, ri) => {\n    determiningTable.columns.forEach((column, ci) => {\n      if (relationships[ri][ci] !== null) {\n        resDFA.transformFunctions.push({\n          from: row,\n          to: relationships[ri][ci]!,\n          input: column\n        });\n      }\n    });\n  });\n\n  return resDFA;\n};\n\nexport default getDFAFromNFA;\n","import { Grammar, END } from './types/grammar';\nimport { LR0AnalysisTable, S, ACC, R } from './types/analysisTable';\nimport getNFAFromGrammar from './utils/fa/getNFAFromGrammar';\nimport getDFAFromNFA from './utils/fa/getDFAFromNFA';\nimport getSortedNFAStatuses from './utils/sort/getSortedNFAStatuses';\nimport deepEqual from '../utils/deepEqual';\nimport getGrammarNChomskyType from './utils/getGrammarNChomskyType';\nimport GrammarNChomskyType from './types/grammarNChomskyType';\n\nconst getLR0AnalysisTable = (grammar: Grammar): LR0AnalysisTable | null => {\n  if (getGrammarNChomskyType(grammar) === GrammarNChomskyType.OTHER) {\n    return null;\n  }\n\n  const depNFA = getNFAFromGrammar(grammar);\n  const depDFA = getDFAFromNFA(depNFA);\n\n  const resTable: LR0AnalysisTable = {\n    states: new Array(depDFA.statuses.length).fill(0).map((_, i) => i),\n    actionColumns: [...grammar.terminals, END],\n    gotoColumns: [...grammar.nonTerminals.filter(t => t !== grammar.startSymbol)],\n    actionTable: [],\n    gotoTable: [],\n    depDFA\n  };\n\n  resTable.actionTable = new Array(resTable.states.length);\n  for (let i = 0; i < resTable.states.length; i++) {\n    resTable.actionTable[i] = new Array(grammar.terminals.length + 1).fill(null);\n  }\n  resTable.gotoTable = new Array(resTable.states.length);\n  for (let i = 0; i < resTable.states.length; i++) {\n    // ignore the start symbol\n    resTable.gotoTable[i] = new Array(grammar.nonTerminals.length - 1).fill(null);\n  }\n\n  const { transformFunctions, statuses } = depDFA;\n\n  // get all Sn in action table and N in goto table\n  for (let i = 0; i < transformFunctions.length; i++) {\n    const transformFunction = transformFunctions[i];\n    const { from, to, input } = transformFunction;\n\n    const fromIndex = statuses.findIndex(s =>\n      deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(from))\n    );\n    const toIndex = statuses.findIndex(s =>\n      deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(to))\n    );\n\n    // Sn in action table\n    if (grammar.terminals.includes(input)) {\n      const inputPos = resTable.actionColumns.indexOf(input);\n      resTable.actionTable[fromIndex][inputPos] = S(toIndex);\n    }\n\n    // N in goto table\n    else {\n      const inputPos = resTable.gotoColumns.indexOf(input);\n      resTable.gotoTable[fromIndex][inputPos] = toIndex;\n    }\n  }\n\n  // and we need finish acc, rn\n  // find 'reduce project' in DFA accepted statuses to get rn and acc\n  const { acceptedStatuses } = depDFA;\n  for (let i = 0; i < acceptedStatuses.length; i++) {\n    const acceptedStatus = acceptedStatuses[i];\n    const statusIndex = statuses.findIndex(s =>\n      deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(acceptedStatus))\n    );\n\n    // find the reduce project in it\n    const reduceProject = acceptedStatus.filter(s => s.pointPos === s.right.length);\n    // reduce conflict\n    // not LR(0) grammar\n    if (reduceProject.length > 1) {\n      return null;\n    }\n\n    if (reduceProject.length === 1) {\n      // accepted project\n      if (reduceProject[0].left === grammar.startSymbol) {\n        resTable.actionTable[statusIndex][resTable.actionColumns.length - 1] = ACC;\n      }\n\n      // reduce project\n      else {\n        // should confirm the index of candidate 'j'\n        // so that we can get 'rj'\n\n        let visitedNum = 0;\n        for (let i = 0; i < grammar.productions.length; i++) {\n          const production = grammar.productions[i];\n\n          if (production.left[0] === reduceProject[0].left) {\n            for (let j = 0; j < production.right.length; j++) {\n              const candidate = production.right[j];\n\n              if (candidate.join('') === reduceProject[0].right.join('')) {\n                // fill the row with rj\n                for (let k = 0; k < resTable.actionColumns.length; k++) {\n                  // conflict\n                  // not LR(0) grammar\n                  if (resTable.actionTable[statusIndex][k] !== null) {\n                    return null;\n                  }\n\n                  resTable.actionTable[statusIndex][k] = R(visitedNum + j);\n                }\n              }\n            }\n          }\n\n          visitedNum += production.right.length;\n        }\n      }\n    }\n  }\n\n  return resTable;\n};\n\nexport default getLR0AnalysisTable;\n","import { Grammar, END } from './types/grammar';\nimport { S, ACC, R, SLR1AnalysisTable } from './types/analysisTable';\nimport getNFAFromGrammar from './utils/fa/getNFAFromGrammar';\nimport getDFAFromNFA from './utils/fa/getDFAFromNFA';\nimport getSortedNFAStatuses from './utils/sort/getSortedNFAStatuses';\nimport deepEqual from '../utils/deepEqual';\nimport getFollowSet from './getFollowSet';\nimport getGrammarNChomskyType from './utils/getGrammarNChomskyType';\nimport GrammarNChomskyType from './types/grammarNChomskyType';\n\nconst getSLR1AnalysisTable = (grammar: Grammar): SLR1AnalysisTable | null => {\n  if (getGrammarNChomskyType(grammar) === GrammarNChomskyType.OTHER) {\n    return null;\n  }\n\n  const depNFA = getNFAFromGrammar(grammar);\n  const depDFA = getDFAFromNFA(depNFA);\n\n  const resTable: SLR1AnalysisTable = {\n    states: new Array(depDFA.statuses.length).fill(0).map((_, i) => i),\n    actionColumns: [...grammar.terminals, END],\n    gotoColumns: [...grammar.nonTerminals.filter(t => t !== grammar.startSymbol)],\n    actionTable: [],\n    gotoTable: [],\n    depDFA\n  };\n\n  resTable.actionTable = new Array(resTable.states.length);\n  for (let i = 0; i < resTable.states.length; i++) {\n    resTable.actionTable[i] = new Array(grammar.terminals.length + 1).fill(null);\n  }\n  resTable.gotoTable = new Array(resTable.states.length);\n  for (let i = 0; i < resTable.states.length; i++) {\n    // ignore the start symbol\n    resTable.gotoTable[i] = new Array(grammar.nonTerminals.length - 1).fill(null);\n  }\n\n  const { transformFunctions, statuses } = depDFA;\n\n  // get all Sn in action table and N in goto table\n  for (let i = 0; i < transformFunctions.length; i++) {\n    const transformFunction = transformFunctions[i];\n    const { from, to, input } = transformFunction;\n\n    const fromIndex = statuses.findIndex(s =>\n      deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(from))\n    );\n    const toIndex = statuses.findIndex(s =>\n      deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(to))\n    );\n\n    // Sn in action table\n    if (grammar.terminals.includes(input)) {\n      const inputPos = resTable.actionColumns.indexOf(input);\n      resTable.actionTable[fromIndex][inputPos] = S(toIndex);\n    }\n\n    // N in goto table\n    else {\n      const inputPos = resTable.gotoColumns.indexOf(input);\n      resTable.gotoTable[fromIndex][inputPos] = toIndex;\n    }\n  }\n\n  // and we need finish acc, rn\n  // find 'reduce project' in DFA accepted statuses to get rn and acc\n  const { acceptedStatuses } = depDFA;\n  for (let i = 0; i < acceptedStatuses.length; i++) {\n    const acceptedStatus = acceptedStatuses[i];\n    const statusIndex = statuses.findIndex(s =>\n      deepEqual(getSortedNFAStatuses(s), getSortedNFAStatuses(acceptedStatus))\n    );\n\n    // find the reduce project in it\n    const reduceProject = acceptedStatus.filter(s => s.pointPos === s.right.length);\n    // reduce conflict\n    // not LR(0) grammar\n    if (reduceProject.length > 1) {\n      return null;\n    }\n\n    if (reduceProject.length === 1) {\n      // accepted project\n      if (reduceProject[0].left === grammar.startSymbol) {\n        resTable.actionTable[statusIndex][resTable.actionColumns.length - 1] = ACC;\n      }\n\n      // reduce project\n      else {\n        // should confirm the index of candidate 'j'\n        // so that we can get 'rj'\n\n        let visitedNum = 0;\n        for (let i = 0; i < grammar.productions.length; i++) {\n          const production = grammar.productions[i];\n\n          if (production.left[0] === reduceProject[0].left) {\n            for (let j = 0; j < production.right.length; j++) {\n              const candidate = production.right[j];\n\n              if (candidate.join('') === reduceProject[0].right.join('')) {\n                // get FOLLOW set\n                // the only difference between LR(0) and SLR(1)\n                const followSet = getFollowSet(grammar, production.left[0]);\n                const indexes = followSet.map(c => resTable.actionColumns.indexOf(c));\n\n                for (let k = 0; k < indexes.length; k++) {\n                  const index = indexes[k];\n\n                  // conflict\n                  // not SLR(1) grammar\n                  if (resTable.actionTable[statusIndex][index] !== null) {\n                    return null;\n                  }\n\n                  resTable.actionTable[statusIndex][index] = R(visitedNum + j);\n                }\n              }\n            }\n          }\n\n          visitedNum += production.right.length;\n        }\n      }\n    }\n  }\n\n  return resTable;\n};\n\nexport default getSLR1AnalysisTable;\n","import React from 'react'\r\nimport { Card, Typography } from 'antd'\r\n\r\ninterface IProps {\r\n  grammarTypes: string[] | null;\r\n}\r\n\r\nexport default function Summary(props: IProps) {\r\n  return (\r\n    <Card title=\"Summary\" style={{\r\n      marginTop: '20px'\r\n    }}>\r\n      <Typography>\r\n        {\r\n          props.grammarTypes === null ?\r\n          <Typography.Paragraph>\r\n            Wait...\r\n          </Typography.Paragraph> :\r\n          <>\r\n            {\r\n              props.grammarTypes.length === 0 ?\r\n              <Typography.Paragraph><b>This grammar isn't any grammar above!</b></Typography.Paragraph> :\r\n              <Typography.Paragraph><b>{`This grammar is a ${props.grammarTypes.join(', ')} grammar.`}</b></Typography.Paragraph>\r\n            }\r\n\r\n            <Typography.Paragraph>\r\n              You can click the button \"â†‘\" in the right bottom to go back to top.\r\n            </Typography.Paragraph>\r\n          </>\r\n        }\r\n      </Typography>\r\n    </Card>\r\n  )\r\n}\r\n","import React from 'react'\r\nimport {Layout} from 'antd';\r\n\r\nconst AntdFooter = Layout.Footer;\r\n\r\nexport default function Footer() {\r\n  return (\r\n    <AntdFooter style={{\r\n      textAlign: 'center'\r\n    }}>\r\n      <span role=\"img\" aria-label=\"\">ðŸš€ Developed by Qinglong Zhang<br></br></span>\r\n    </AntdFooter>\r\n  )\r\n}\r\n","import React from 'react';\nimport Header from '../components/Header';\nimport GrammarInput from '../components/GrammarInput';\nimport { Divider, Row, Col, message, BackTop } from 'antd';\nimport { Grammar } from '../grammar-analysis/types/grammar';\nimport FirstAndFollowSetCompute from '../components/FirstAndFollowSetShow';\nimport LL1AnalysisTableCompute from '../components/LL1AnalysisTableCompute';\nimport LR0AnalysisTableCompute from '../components/LR0AnalysisTableCompute';\nimport SLR1AnalysisTableCompute from '../components/SLR1AnalysisTableCompute';\nimport AnalysisSteps from '../components/AnalysisSteps';\nimport {\n  LL1AnalysisTable,\n  LR0AnalysisTable,\n  SLR1AnalysisTable\n} from '../grammar-analysis/types/analysisTable';\nimport getFirstSetAndFollowSet, {\n  IFirstAndFollowSet\n} from '../utils/compute/getFirstSetAndFollowSet';\nimport getLL1AnalysisTable from '../grammar-analysis/getLL1AnalysisTable';\nimport getLR0AnalysisTable from '../grammar-analysis/getLR0AnalysisTable';\nimport getSLR1AnalysisTable from '../grammar-analysis/getSLR1AnalysisTable';\nimport Summary from '../components/Summary';\nimport Footer from '../components/Footer';\n\ninterface IState {\n  stepsStatus: boolean[];\n  computeRes: {\n    firstAndFollowSet: IFirstAndFollowSet[];\n    ll1AnalysisTable: LL1AnalysisTable | null | undefined;\n    lr0AnalysisTable: LR0AnalysisTable | null | undefined;\n    slr1AnalysisTable: SLR1AnalysisTable | null | undefined;\n  };\n}\n\nexport default class Index extends React.Component<{}, IState> {\n  state = {\n    stepsStatus: new Array(6).fill(undefined),\n    computeRes: {\n      firstAndFollowSet: [],\n      ll1AnalysisTable: undefined,\n      lr0AnalysisTable: undefined,\n      slr1AnalysisTable: undefined\n    }\n  };\n\n  startComputeHandler = (grammar: Grammar) => {\n    const firstAndFollowSet = getFirstSetAndFollowSet(grammar);\n    const ll1AnalysisTable = getLL1AnalysisTable(grammar);\n    const lr0AnalysisTable = getLR0AnalysisTable(grammar);\n    const slr1AnalysisTable = getSLR1AnalysisTable(grammar);\n\n    this.setState({\n      computeRes: {\n        firstAndFollowSet,\n        ll1AnalysisTable,\n        lr0AnalysisTable,\n        slr1AnalysisTable\n      },\n      stepsStatus: [\n        true,\n        true,\n        ll1AnalysisTable !== null,\n        lr0AnalysisTable !== null,\n        slr1AnalysisTable !== null,\n        true\n      ]\n    });\n\n    message.info('All computations have finished!');\n  };\n\n  getGrammarTypes = () => {\n    const {stepsStatus} = this.state;\n\n    if(stepsStatus[2] === undefined) {\n      return null;\n    }\n\n    const grammarTables = stepsStatus.slice(2, 5);\n    return ['LL(1)', 'LR(0)', 'SLR(1)'].filter((t, i) => grammarTables[i]);\n  }\n\n  confirmHandler = () => {\n    message.success(\"You've confirm the grammar, now you can start to compute!\");\n    this.setState({\n      stepsStatus: [true].concat(new Array(5).fill(undefined))\n    });\n  };\n\n  inputHandler = () => {\n    this.setState({\n      stepsStatus: new Array(6).fill(undefined)\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <Header />\n        <Divider />\n\n        <Row>\n          <Col span={20}>\n            <main\n              style={{\n                padding: '0px 50px 50px 50px'\n              }}\n            >\n              <GrammarInput\n                onStartCompute={this.startComputeHandler}\n                onInput={this.inputHandler}\n                onConfirm={this.confirmHandler}\n              />\n\n              <FirstAndFollowSetCompute data={this.state.computeRes.firstAndFollowSet} />\n\n              <LL1AnalysisTableCompute table={this.state.computeRes.ll1AnalysisTable} />\n\n              <LR0AnalysisTableCompute table={this.state.computeRes.lr0AnalysisTable} />\n\n              <SLR1AnalysisTableCompute table={this.state.computeRes.slr1AnalysisTable} />\n\n              <Summary grammarTypes={this.getGrammarTypes()} />\n            </main>\n          </Col>\n\n          <Col span={4}>\n            <AnalysisSteps statues={this.state.stepsStatus} />\n          </Col>\n        </Row>\n\n        <Footer />\n\n        <BackTop />\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport './App.css';\nimport Index from './pages/Index';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Index />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}